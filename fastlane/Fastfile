# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#

default_platform(:ios)

platform :ios do

  before_all do

    xcode_select("/Applications/Xcode.app")

  end

  desc "Generate project and install pods"
  lane :prepare do
    xcodegen
    cocoapods(try_repo_update_on_error: true)
  end

  desc "Register new devices"
  lane :register_new_devices do
    register_devices(devices_file: "./fastlane/devices.txt", username: "me@trykov.ru")
    register_new_devices_production
    register_new_devices_beta
  end

  lane :register_new_devices_production do
    match(type: "development", force_for_new_devices: true)
    match(type: "adhoc", force_for_new_devices: true)
    match(type: "appstore", force_for_new_devices: true)
  end

  desc "Download certificates"
  lane :certificates do
    match(type: "development", readonly: true)
    match(type: "adhoc", readonly: true)
    match(type: "appstore", readonly: true)
  end

  desc "Renew certificates for production scheme"
  lane :renew_production_certificates do
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    match(type: "development",
          app_identifier: app_identifier,
          force_for_new_devices: true)
    match(type: "adhoc",
          app_identifier: app_identifier,
          force: true)
    match(type: "appstore",
          app_identifier: app_identifier,
          force: true)
  end

  desc "Renew certificates for beta scheme"
  lane :renew_beta_certificates do
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    match(type: "development",
          app_identifier: app_identifier,
          force_for_new_devices: true)
    match(type: "adhoc",
          app_identifier: app_identifier,
          force: true)
    match(type: "appstore",
          app_identifier: app_identifier,
          force: true)
  end

  desc "Run the static analyzer on the iOS project"
  lane :analyze do
    swiftlint(
          mode: :lint,      # SwiftLint mode: :lint (default) or :autocorrect
          output_file: "swiftlint.result.json", # The path of the output file (optional)
          config_file: ".swiftlint.yml",     # The path of the configuration file (optional)
          ignore_exit_status: true    # Allow fastlane to continue even if SwiftLint returns a non-zero exit status
     )
  end

  desc "Increment build number on the iOS project and commit it"
  lane :increment do
    project_file = 'RK.xcodeproj'
    # Ensure that your git status is not dirty
    ensure_git_status_clean

    # Increment the build number (not the version number)
    # Providing the xcodeproj is optional
    increment_build_number(xcodeproj: project_file,
                            build_number: ENV['CI_PIPELINE_ID'])

    # Commit the version bump
    commit_version_bump(
          message: 'Version Bump by fastlane',
          xcodeproj: project_file
    )

    # Push the new commit and tag back to your git remote
    push_to_git_remote
  end

  desc "Create new screenshots for the App Store in all languages and device types"
  desc "Additionally, this will add device frames around the screenshots and add the correct titles"
  lane :screenshots do
    snapshot
    frameit(white: true, path: './fastlane/screenshots')
  end

  desc "Uploads metadata only - no ipa file will be uploaded"
  desc "You'll get a summary of the collected metadata before it's uploaded"
  lane :upload_metadata do
    deliver(metadata_only: true)
  end

  desc "Build scheme in debug mode and upload to Crashlytics"
  lane :beta do |values|
    xcodegen
    cocoapods(try_repo_update_on_error: true)
    buildNumber = ENV['CI_PIPELINE_ID']
    UI.message"build number is here: #{buildNumber}"

    increment_build_number(xcodeproj: 'RK.xcodeproj',
                          build_number: buildNumber)

    build_app(
              scheme: "RK-beta",
              export_method: 'ad-hoc',
              export_xcargs: "-allowProvisioningUpdates",
              export_options: {
                    iCloudContainerEnvironment: 'Development',
                    compileBitcode: false,
                    provisioningProfiles: {
                                          "ru.trykov.roskachestvo" => "match AdHoc ru.trykov.roskachestvo"
                                        }
              },
              clean: true
            )
  end

  desc "Upload to Crashlytics"
  lane :upload_crashlytics do |values|
    version     = get_version_number(xcodeproj: "RK.xcodeproj", target: "RK")
    build       = ENV['CI_PIPELINE_ID'] ? ENV['CI_PIPELINE_ID'] : get_build_number(xcodeproj: "RK.xcodeproj")
    emails = values[:test_email] ? values[:test_email] : nil
    groups = values[:test_email] ? nil : ['qa-heal'] # You can define groups on the web and reference them here
    crashlytics(    api_token: ENV["CRASHLYTICS_API_TOKEN"],
                 build_secret: ENV["CRASHLYTICS_SECRET"],
                       emails: emails,
                       groups: 'groups',
                        notes: default_changelog,
                notifications: true)
    upload_dsyms()
  end

  desc "Upload to Firebase beta"
  desc "Requires firebase cli https://firebase.google.com/docs/cli"
  desc "Download an install 'curl -sL firebase.tools | bash'"
  desc "Login local machine 'firebase login' or ci 'firebase login:ci'"
  desc "If CI machine - use FIREBASE_TOKEN for firebase_cli_token params"
  lane :upload_firebase do |values|
    version     = get_version_number(xcodeproj: "RK.xcodeproj", target: "RK")
    build       = ENV['CI_PIPELINE_ID'] ? ENV['CI_PIPELINE_ID'] : get_build_number(xcodeproj: "RK.xcodeproj")
    groups = values[:test_email] ? nil : 'qa-heal' # You can define groups on the web and reference them here
    firebase_app_distribution(
                  app: ENV["FIREBASE_BETA_APP"],
                  groups: groups,
                  firebase_cli_token: ENV["FIREBASE_TOKEN"],
                  release_notes: default_changelog
                  )
  end

  desc "Upload to TestFlight"
  lane :upload_testflight do
    version     = get_version_number(xcodeproj: "RK.xcodeproj", target: "RK")
    build       = ENV['CI_PIPELINE_ID'] ? ENV['CI_PIPELINE_ID'] : get_build_number(xcodeproj: "RK.xcodeproj")
    pilot(skip_waiting_for_build_processing: true)
  end

  desc "Returns a default changelog."
  lane :default_changelog do
    changelog = changelog_from_git_commits(
        between: [ENV['GIT_PREVIOUS_SUCCESSFUL_COMMIT'] || "HEAD^^^^^", "HEAD"],
        pretty: "- %s"
    )
    # HAX: strip emoji from changelog
    changelog = changelog.sub(/[\u{1F300}-\u{1F6FF}]/, '')
    Actions.lane_context[SharedValues::FL_CHANGELOG] = changelog
    puts changelog
    # Добавляем имя ветки в начало changelog'a
    changelog = "Задача в JIRA: #{git_branch}\n" + changelog
    UI.message"#{changelog}"
    changelog
  end

  desc "Build, sign and upload a new beta build to Apple TestFlight"
  desc "This will **not** send an email to all testers, it will only be uploaded to the new TestFlight. "
  desc "CI build set build number with TC, on local build increment by latest at Test Flight"
  lane :release do |values|
    if is_ci
      buildNumber = ENV['CI_PIPELINE_ID']
      UI.message"build number is here: #{buildNumber}"
      increment_build_number(xcodeproj: 'RK.xcodeproj',
                             build_number: buildNumber)
    else
      increment
    end
    app_identifier = CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
    apple_id = CredentialsManager::AppfileConfig.try_fetch_value(:apple_id)
    build_app(
              scheme: "RK",
              export_method: "app-store",
              clean: true
            )
  end

end
